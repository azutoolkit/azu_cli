require "../core/abstract_generator"
require "./model_generator"
require "./service_generator"
require "./endpoint_generator"
require "./contract_generator"
require "./page_generator"
require "./migration_generator"

module AzuCLI::Generator
  # Optimized Scaffold Generator following SOLID principles
  # Orchestrates multiple generators to create complete CRUD resources
  class ScaffoldGenerator < Core::AbstractGenerator
    property attributes : Hash(String, String)
    property actions : Array(String)
    property skip_components : Array(String)
    property api_only : Bool
    property web_only : Bool

    def initialize(name : String, project_name : String, options : Core::GeneratorOptions)
      @attributes = options.attributes
      @actions = extract_actions(options)
      @skip_components = extract_skip_components(options)
      @api_only = options.custom_options["api-only"]? == "true"
      @web_only = options.custom_options["web-only"]? == "true"
      super(name, project_name, options.force, options.skip_tests)
    end

    def generator_type : String
      "scaffold"
    end

    def generate_files : Nil
      puts "ðŸ—ï¸ Generating scaffold for #{class_name}...".colorize(:cyan).bold
      puts

      # Generate components in dependency order
      generation_order.each do |step, component_type|
        next if skip_components.includes?(component_type)
        next if should_skip_component?(component_type)

        puts "#{step}. Generating #{component_type}...".colorize(:yellow)
        generate_component(component_type)
      end
    end

    def create_directories : Nil
      super

      # Create all directories needed by scaffold components
      directories_config = config.get_hash("directories")
      directories_config.each do |dir_type, dir_path|
        file_strategy.create_directory(dir_path)
      end
    end

    def generate_tests : Nil
      return if skip_tests

      # Tests are generated by individual component generators
      puts "âœ… Tests generated by component generators".colorize(:green)
    end

    # Extract actions from options or use defaults
    private def extract_actions(options : Core::GeneratorOptions) : Array(String)
      explicit_actions = options.additional_args.reject { |arg| arg.includes?(":") }

      if explicit_actions.empty?
        config.get_array("default_actions")
      else
        explicit_actions
      end
    end

    # Extract skip components from options
    private def extract_skip_components(options : Core::GeneratorOptions) : Array(String)
      skipped = [] of String

      scaffold_options = config.get_hash("scaffold_options")
      scaffold_options.each do |option_key, default_value|
        if option_key.starts_with?("skip_") && options.custom_options[option_key]? == "true"
          component = option_key.gsub("skip_", "")
          skipped << component
        end
      end

      skipped
    end

    # Get generation order from configuration
    private def generation_order : Hash(Int32, String)
      order_config = config.get_hash("generation_order")
      order = {} of Int32 => String

      order_config.each do |step_str, component|
        step = step_str.to_i
        order[step] = component
      end

      order
    end

    # Check if component should be skipped based on options
    private def should_skip_component?(component_type : String) : Bool
      case component_type
      when "page"
        return true if @api_only
      when "template"
        return true if @api_only
      end

      false
    end

    # Generate individual component using appropriate generator
    private def generate_component(component_type : String) : Nil
      case component_type
      when "migration"
        generate_migration_component
      when "model"
        generate_model_component
      when "service"
        generate_service_component
      when "contract"
        generate_contract_component
      when "endpoint"
        generate_endpoint_component
      when "page"
        generate_page_component
      else
        puts "  âš ï¸ Unknown component type: #{component_type}".colorize(:yellow)
      end
    end

    # Generate migration using MigrationGenerator
    private def generate_migration_component : Nil
      migration_options = create_component_options("migration")
      generator = MigrationGenerator.new(name, project_name, migration_options)
      generator.generate!
    end

    # Generate model using ModelGenerator
    private def generate_model_component : Nil
      model_options = create_component_options("model")
      generator = ModelGenerator.new(name, project_name, model_options)
      generator.generate!
    end

    # Generate service using ServiceGenerator
    private def generate_service_component : Nil
      service_options = create_component_options("service")
      service_options.custom_options["type"] = "crud" # Default to CRUD service for scaffold
      generator = ServiceGenerator.new(name, project_name, service_options)
      generator.generate!
    end

    # Generate contracts using ContractGenerator
    private def generate_contract_component : Nil
      # Generate contracts for each action
      @actions.each do |action|
        contract_name = "#{name}::#{action.capitalize}"
        contract_options = create_component_options("contract")
        contract_options.custom_options["action"] = action
        contract_options.custom_options["type"] = determine_contract_type(action)

        generator = ContractGenerator.new(contract_name, project_name, contract_options)
        generator.generate!
      end
    end

    # Generate endpoints using EndpointGenerator
    private def generate_endpoint_component : Nil
      endpoint_options = create_component_options("endpoint")
      endpoint_options.additional_args = @actions
      generator = EndpointGenerator.new(name, project_name, endpoint_options)
      generator.generate!
    end

    # Generate pages using PageGenerator
    private def generate_page_component : Nil
      return if @api_only

      # Generate page for each action that needs one
      page_actions = @actions.select { |action| needs_page?(action) }

      page_actions.each do |action|
        page_name = "#{name}::#{action.capitalize}Page"
        page_options = create_component_options("page")
        page_options.custom_options["action"] = action
        page_options.custom_options["template_vars"] = generate_page_template_vars(action)

        generator = PageGenerator.new(page_name, project_name, page_options)
        generator.generate!
      end
    end

    # Create component-specific options
    private def create_component_options(component_type : String) : Core::GeneratorOptions
      options = Core::GeneratorOptions.new
      options.attributes = @attributes
      options.force = force
      options.skip_tests = skip_tests
      options.custom_options = {} of String => String
      options.additional_args = [] of String

      # Add component-specific customizations
      case component_type
      when "model"
        options.custom_options["migration"] = "false" # Migration handled separately
      when "service"
        options.additional_args = ["create", "find", "update", "delete", "list"]
      end

      options
    end

    # Determine contract type based on action
    private def determine_contract_type(action : String) : String
      case action
      when "index", "show"
        "request"
      when "create", "update"
        "request"
      else
        "request"
      end
    end

    # Check if action needs a page
    private def needs_page?(action : String) : Bool
      ["index", "show", "new", "edit"].includes?(action)
    end

    # Generate template variables for page actions
    private def generate_page_template_vars(action : String) : String
      case action
      when "index"
        "items:Array(#{class_name}),page:Int32,total:Int32"
      when "show"
        "item:#{class_name}"
      when "new"
        "item:#{class_name},errors:Hash(String,String)"
      when "edit"
        "item:#{class_name},errors:Hash(String,String)"
      else
        "item:#{class_name}"
      end
    end

    # Override success message for scaffold
    def success_message : String
      features = [] of String
      features << "#{@actions.size} action(s)"
      features << "#{@attributes.size} attribute(s)" unless @attributes.empty?
      features << "API only" if @api_only
      features << "Web only" if @web_only

      "âœ… Scaffold generated for #{class_name} with #{features.join(", ")}"
    end

    # Override to show scaffold-specific next steps
    def post_generation_tasks : Nil
      super
      show_scaffold_usage_info
    end

    # Show scaffold usage information
    private def show_scaffold_usage_info
      puts
      puts "ðŸš€ Scaffold Complete!".colorize(:green).bold
      puts
      puts "Generated components:".colorize(:yellow).bold
      generated_components.each_with_index do |component, index|
        next if skip_components.includes?(component) || should_skip_component?(component)
        puts "  #{index + 1}. #{component.capitalize}"
      end
      puts

      puts "Next steps:".colorize(:yellow).bold

      unless skip_components.includes?("migration")
        puts "  1. Run migration: azu db:migrate"
      end

      puts "  2. Add routes to your application:"
      generate_route_examples.each do |route|
        puts "     #{route}"
      end

      puts "  3. Customize the generated components:"
      puts "     - Add validations to the model"
      puts "     - Implement business logic in the service"
      puts "     - Customize endpoint actions"
      puts "     - Style the pages" unless @api_only

      puts "  4. Test your scaffold:"
      puts "     crystal spec spec/models/#{snake_case_name}_spec.cr"
      puts "     crystal spec spec/services/#{snake_case_name}_service_spec.cr"
      puts "     crystal spec spec/endpoints/#{snake_case_name}*_spec.cr"

      puts
      puts "ðŸ“š Learn more: https://azutopia.gitbook.io/azu/scaffolding".colorize(:cyan)
    end

    # Generate route examples
    private def generate_route_examples : Array(String)
      routes = [] of String
      resource_route = snake_case_name.gsub("_", "-")

      if @actions.includes?("index")
        routes << "get \"/#{plural_name}\", #{class_name}Endpoint::IndexEndpoint"
      end

      if @actions.includes?("show")
        routes << "get \"/#{plural_name}/:id\", #{class_name}Endpoint::ShowEndpoint"
      end

      if @actions.includes?("create")
        routes << "post \"/#{plural_name}\", #{class_name}Endpoint::CreateEndpoint"
      end

      if @actions.includes?("update")
        routes << "put \"/#{plural_name}/:id\", #{class_name}Endpoint::UpdateEndpoint"
      end

      if @actions.includes?("destroy")
        routes << "delete \"/#{plural_name}/:id\", #{class_name}Endpoint::DestroyEndpoint"
      end

      routes
    end

    # Get generated components from configuration
    private def generated_components : Array(String)
      config.get_array("generated_components")
    end

    # Override to show more detailed information
    def validate_preconditions : Nil
      super

      # Validate scaffold-specific preconditions
      if @attributes.empty?
        puts "âš ï¸ Warning: No attributes specified. Scaffold will generate basic structure only.".colorize(:yellow)
      end

      if @actions.empty?
        puts "âš ï¸ Warning: No actions specified. Using default CRUD actions.".colorize(:yellow)
      end
    end

    # Show scaffold planning information
    def show_scaffold_plan
      puts "ðŸ“‹ Scaffold Plan:".colorize(:cyan).bold
      puts "   Resource: #{class_name}"
      puts "   Attributes: #{@attributes.map { |k, v| "#{k}:#{v}" }.join(", ")}" unless @attributes.empty?
      puts "   Actions: #{@actions.join(", ")}"
      puts "   Components: #{generated_components.reject { |c| skip_components.includes?(c) || should_skip_component?(c) }.join(", ")}"
      puts "   Type: #{@api_only ? "API Only" : @web_only ? "Web Only" : "Full Stack"}"
      puts
    end

    # Override generate! to show plan first
    def generate! : String
      validate_input!
      show_scaffold_plan

      puts "Generating scaffold...".colorize(:green).bold
      puts

      super
    end
  end
end
