<%- if using_authly? %>
<%# Requires first (Crystal convention) %>
require "authly"
require "../../models/user"
<%- if using_jwt? %>
require "jwt"
<%- end %>

module <%= project.camelcase %>::Auth
  struct OAuthCallbackEndpoint
    include Azu::Endpoint(Azu::Request, Azu::Response::Empty | Auth::LoginResponse)

    get "/auth/oauth/:provider/callback"

    def call : Azu::Response::Empty | Auth::LoginResponse
      provider = params[":provider"]? || params["provider"]?
      code = params["code"]?
      state = params["state"]?
      unless provider
        context.response.status = HTTP::Status::BAD_REQUEST
        context.response.content_type = "application/json"
        context.response.print({error: "provider required"}.to_json)
        return Azu::Response::Empty.new
      end
      unless code
        context.response.status = HTTP::Status::BAD_REQUEST
        context.response.content_type = "application/json"
        context.response.print({error: "code required"}.to_json)
        return Azu::Response::Empty.new
      end

      callback = oauth_callback_url(provider)
      token = Authly.exchange_code(provider, code, callback, state)
      profile = Authly.fetch_profile(provider, token)

      email = profile["email"]?.try(&.to_s)
      name = profile["name"]?.try(&.to_s)
      unless email
        context.response.status = HTTP::Status::UNPROCESSABLE_ENTITY
        context.response.content_type = "application/json"
        context.response.print({error: "email not available from provider"}.to_json)
        return Azu::Response::Empty.new
      end

      user = ::User.find_by(email: email) || begin
        u = ::User.new
        u.email = email
        u.name = name
        # set random password to allow later password flow if desired
        u.password = Random::Secure.urlsafe_base64(24)
        u.save!
        u
      end

      <%- if using_jwt? %>
      access = generate_access_token(user)
      refresh = generate_refresh_token(user)
      Auth::LoginResponse.new(user.id, access, refresh)
      <%- else %>
      session["user_id"] = user.id
      redirect to: "/"
      <%- end %>
    end

    private def oauth_callback_url(provider : String) : String
      base = ENV["APP_URL"]? || "http://localhost:4000"
      "#{base}/auth/oauth/#{provider}/callback"
    end

    <%- if using_jwt? %>
    private def generate_access_token(user : ::User) : String
      now = Time.utc
      payload = {
        "sub" => user.id.to_s,
        "iat" => now.to_unix,
        "exp" => (now + 15.minutes).to_unix,
        "iss" => jwt_issuer,
        "aud" => jwt_audience,
        "role" => user.role,
      }
      JWT.encode(payload, jwt_secret, JWT::Algorithm::HS256)
    end

    private def generate_refresh_token(user : ::User) : String
      now = Time.utc
      payload = {
        "sub" => user.id.to_s,
        "iat" => now.to_unix,
        "exp" => (now + 7.days).to_unix,
        "type" => "refresh",
      }
      JWT.encode(payload, jwt_refresh_secret, JWT::Algorithm::HS256)
    end

    private def jwt_secret : String
      ENV["JWT_SECRET"]? || raise "JWT_SECRET environment variable not set"
    end

    private def jwt_refresh_secret : String
      ENV["JWT_REFRESH_SECRET"]? || raise "JWT_REFRESH_SECRET environment variable not set"
    end

    private def jwt_issuer : String
      ENV["JWT_ISSUER"]? || "<%= project.downcase %>-api"
    end

    private def jwt_audience : String
      ENV["JWT_AUDIENCE"]? || "<%= project.downcase %>-client"
    end
    <%- end %>
  end
end
<%- end %>


