<%# Requires first (Crystal convention) %>
require "../../models/user"
require "../../requests/auth/register_request"
require "../../response/auth/register_json"
require "../../validators/email_validator"
require "../../validators/strong_password_validator"
require "../../validators/password_confirmation_validator"
<%- if using_jwt? || using_authly? %>
require "jwt"
<%- end %>

module <%= project.camelcase %>::Auth
  struct RegisterEndpoint
    include Azu::Endpoint(Auth::RegisterRequest, Auth::RegisterResponse | Azu::Response::Empty)

    post "/auth/register"

    def call : Auth::RegisterResponse | Azu::Response::Empty
      req = register_request

      # Validate request using Schema validation
      unless req.valid?
        context.response.status = HTTP::Status::UNPROCESSABLE_ENTITY
        context.response.content_type = "application/json"
        # Schema errors format: errors is a collection of Schema::Error objects
        error_hash = {} of String => Array(String)
        req.errors.each do |error|
          field = error.field.to_s
          error_hash[field] ||= [] of String
          error_hash[field] << error.message
        end
        context.response.print({errors: error_hash}.to_json)
        return Azu::Response::Empty.new
      end

      if ::<%= user_model_class %>.find_by(email: req.email)
        context.response.status = HTTP::Status::UNPROCESSABLE_ENTITY
        context.response.content_type = "application/json"
        context.response.print({errors: {email: ["already exists"]}}.to_json)
        return Azu::Response::Empty.new
      end

      user = ::<%= user_model_class %>.new
      user.email = req.email
      user.password = req.password
      user.name = req.name

      unless user.save
        context.response.status = HTTP::Status::UNPROCESSABLE_ENTITY
        context.response.content_type = "application/json"
        context.response.print({errors: user.errors}.to_json)
        return Azu::Response::Empty.new
      end

      <%- if using_jwt? || using_authly? %>
      access = generate_access_token(user)
      refresh = generate_refresh_token(user)
      Auth::RegisterResponse.new(user.id, access, refresh)
      <%- else %>
      current_session.data.<%= user_model_singular %>_id = user.id
      current_session.data.reset_login_attempts
      Auth::RegisterResponse.new(user.id)
      <%- end %>
    end

    <%- if using_session? %>
    private def current_session : Session::Provider
      <%= project.camelcase %>.session
    end
    <%- end %>

    <%- if using_jwt? || using_authly? %>
    private def generate_access_token(user : ::<%= user_model_class %>) : String
      now = Time.utc
      payload = {
        "sub" => user.id.to_s,
        "iat" => now.to_unix,
        "exp" => (now + 15.minutes).to_unix,
        "iss" => jwt_issuer,
        "aud" => jwt_audience,
        "role" => user.role,
      }
      JWT.encode(payload, jwt_secret, JWT::Algorithm::HS256)
    end

    private def generate_refresh_token(user : ::<%= user_model_class %>) : String
      now = Time.utc
      payload = {
        "sub" => user.id.to_s,
        "iat" => now.to_unix,
        "exp" => (now + 7.days).to_unix,
        "type" => "refresh",
      }
      JWT.encode(payload, jwt_refresh_secret, JWT::Algorithm::HS256)
    end

    private def jwt_secret : String
      ENV["JWT_SECRET"]? || raise "JWT_SECRET environment variable not set"
    end

    private def jwt_refresh_secret : String
      ENV["JWT_REFRESH_SECRET"]? || raise "JWT_REFRESH_SECRET environment variable not set"
    end

    private def jwt_issuer : String
      ENV["JWT_ISSUER"]? || "<%= project.downcase %>-api"
    end

    private def jwt_audience : String
      ENV["JWT_AUDIENCE"]? || "<%= project.downcase %>-client"
    end
    <%- end %>
  end
end


