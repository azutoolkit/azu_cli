# Enhanced Authentication Endpoint with Security Features
# Handles user authentication with comprehensive security measures

require "../models/user"
require "../requests/auth/*"
require "../middleware/csrf_protection"
<%- if using_jwt? || using_authly? %>
require "jwt"
<%- end %>
<%- if using_authly? %>
require "authly"
<%- end %>
<%- if rbac_enabled? %>
require "../models/role"
require "../models/permission"
<%- end %>

module <%=project.camelcase%>::Endpoints
  class AuthEndpoint < Azu::Endpoint
    # Rate limiting for auth endpoints
    MAX_LOGIN_ATTEMPTS = 5
    LOCKOUT_DURATION = 30.minutes

    # POST /auth/register
    post "/auth/register" do
      <%- if csrf_enabled? %>
      # CSRF protection for registration
      csrf_token = CSRFProtection.get_or_create_token(self)
      <%- end %>

      request = RegisterRequest.new(params)

      unless request.valid?
        halt 422, {errors: request.errors}.to_json
      end

      # Check if user already exists
      if User.find_by(email: request.email)
        halt 422, {errors: {email: ["already exists"]}}.to_json
      end

      user = User.new(
        email: request.email,
        password: request.password,
        name: request.name
      )

      if user.save
        <%- if using_jwt? || using_authly? %>
        access_token = generate_access_token(user)
        refresh_token = generate_refresh_token(user)
        json({
          user: user_response(user),
          access_token: access_token,
          refresh_token: refresh_token,
          <%- if csrf_enabled? %>
          csrf_token: csrf_token
          <%- end %>
        }, status: 201)
        <%- else %>
        session["user_id"] = user.id
        json({
          user: user_response(user),
          <%- if csrf_enabled? %>
          csrf_token: csrf_token
          <%- end %>
        }, status: 201)
        <%- end %>
      else
        halt 422, {errors: user.errors}.to_json
      end
    end

    # POST /auth/login
    post "/auth/login" do
      request = LoginRequest.new(params)

      unless request.valid?
        halt 422, {errors: request.errors}.to_json
      end

      # Rate limiting check
      user = User.find_by(email: request.email)
      if user && user.account_locked_due_to_failed_attempts?
        halt 429, {error: "Account temporarily locked due to too many failed attempts"}.to_json
      end

      user = User.authenticate(request.email, request.password)

      unless user
        # Record failed attempt
        if existing_user = User.find_by(email: request.email)
          existing_user.record_failed_login!
        end
        halt 401, {error: "Invalid email or password"}.to_json
      end

      <%- if csrf_enabled? %>
      csrf_token = CSRFProtection.get_or_create_token(self)
      <%- end %>

      <%- if using_jwt? || using_authly? %>
      access_token = generate_access_token(user)
      refresh_token = generate_refresh_token(user)
      json({
        user: user_response(user),
        access_token: access_token,
        refresh_token: refresh_token,
        <%- if csrf_enabled? %>
        csrf_token: csrf_token
        <%- end %>
      })
      <%- else %>
      session["user_id"] = user.id
      json({
        user: user_response(user),
        <%- if csrf_enabled? %>
        csrf_token: csrf_token
        <%- end %>
      })
      <%- end %>
    end

    # POST /auth/refresh
    <%- if using_jwt? || using_authly? %>
    post "/auth/refresh" do
      request = RefreshTokenRequest.new(params)

      unless request.valid?
        halt 422, {errors: request.errors}.to_json
      end

      payload = verify_refresh_token(request.refresh_token)
      unless payload
        halt 401, {error: "Invalid refresh token"}.to_json
      end

      user_id = payload["sub"].as_s.to_i64
      user = User.find(user_id)
      unless user
        halt 401, {error: "User not found"}.to_json
      end

      # Generate new tokens
      access_token = generate_access_token(user)
      new_refresh_token = generate_refresh_token(user)

      json({
        access_token: access_token,
        refresh_token: new_refresh_token
      })
    end
    <%- end %>

    # POST /auth/logout
    post "/auth/logout" do
      <%- if using_session? %>
      session.delete("user_id")
      <%- end %>

      <%- if csrf_enabled? %>
      session.delete("_csrf_token")
      <%- end %>

      json({message: "Logged out successfully"})
    end

    # GET /auth/me
    get "/auth/me" do
      halt 401, {error: "Not authenticated"}.to_json unless current_user

      user = current_user.not_nil!
      <%- if csrf_enabled? %>
      csrf_token = CSRFProtection.get_or_create_token(self)
      <%- end %>

      response_data = {
        user: user_response(user),
        <%- if rbac_enabled? %>
        roles: user.roles.map(&.name),
        permissions: user.permissions.map(&.name),
        <%- end %>
        <%- if csrf_enabled? %>
        csrf_token: csrf_token
        <%- end %>
      }

      json(response_data)
    end

    # POST /auth/change-password
    post "/auth/change-password" do
      halt 401, {error: "Not authenticated"}.to_json unless current_user

      request = ChangePasswordRequest.new(params)
      unless request.valid?
        halt 422, {errors: request.errors}.to_json
      end

      user = current_user.not_nil!

      # Verify current password
      unless user.verify_password(request.current_password)
        halt 401, {error: "Current password is incorrect"}.to_json
      end

      # Update password
      user.password = request.new_password
      if user.save
        json({message: "Password changed successfully"})
      else
        halt 422, {errors: user.errors}.to_json
      end
    end

    <%- if rbac_enabled? %>
    # GET /auth/permissions
    get "/auth/permissions" do
      halt 401, {error: "Not authenticated"}.to_json unless current_user

      user = current_user.not_nil!
      json({
        permissions: user.permissions.map(&.name),
        roles: user.roles.map(&.name)
      })
    end
    <%- end %>

    <%- if using_authly? %>
    # OAuth endpoints using Authly
    # GET /auth/oauth/:provider
    get "/auth/oauth/:provider" do |provider|
      # OAuth provider authorization
      # Implementation depends on Authly configuration
      halt 501, {error: "OAuth provider #{provider} not implemented"}.to_json
    end

    # GET /auth/oauth/:provider/callback
    get "/auth/oauth/:provider/callback" do |provider|
      # OAuth provider callback
      # Implementation depends on Authly configuration
      halt 501, {error: "OAuth callback for #{provider} not implemented"}.to_json
    end
    <%- end %>

    private def user_response(user : User)
      {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        confirmed: user.confirmed?,
        two_factor_enabled: user.two_factor_enabled,
        created_at: user.created_at,
        last_login_at: user.last_login_at
      }
    end

    <%- if using_jwt? || using_authly? %>
    private def generate_access_token(user : User) : String
      now = Time.utc
      payload = {
        "sub" => user.id.to_s,
        "iat" => now.to_unix,
        "exp" => (now + 15.minutes).to_unix,
        "nbf" => now.to_unix,
        "role" => user.role,
        "iss" => jwt_issuer,
        "aud" => jwt_audience,
        "jti" => generate_jti
      }
      JWT.encode(payload, jwt_secret, JWT::Algorithm::HS256)
    end

    private def generate_refresh_token(user : User) : String
      payload = {
        "sub" => user.id.to_s,
        "type" => "refresh",
        "iat" => Time.utc.to_unix,
        "exp" => (Time.utc + 7.days).to_unix,
        "jti" => generate_jti
      }
      JWT.encode(payload, jwt_refresh_secret, JWT::Algorithm::HS256)
    end

    private def verify_refresh_token(token : String) : Hash(String, JSON::Any)?
      payload, header = JWT.decode(token, jwt_refresh_secret, JWT::Algorithm::HS256)

      # Validate it's a refresh token
      return nil unless payload["type"]? == "refresh"

      # Validate claims
      validate_token_claims(payload)
      payload
    rescue JWT::Error
      nil
    end

    private def generate_jti : String
      UUID.random.to_s
    end

    private def validate_token_claims(payload : Hash(String, JSON::Any)) : Bool
      # Check issuer
      return false unless payload["iss"]? == jwt_issuer

      # Check audience
      return false unless payload["aud"]? == jwt_audience

      # Check expiration
      exp = payload["exp"]?.try(&.as_i)
      return false unless exp && Time.unix(exp) > Time.utc

      # Check not before
      nbf = payload["nbf"]?.try(&.as_i)
      return false unless nbf && Time.unix(nbf) <= Time.utc

      true
    end

    private def jwt_secret : String
      ENV["JWT_SECRET"]? || raise "JWT_SECRET environment variable not set"
    end

    private def jwt_refresh_secret : String
      ENV["JWT_REFRESH_SECRET"]? || raise "JWT_REFRESH_SECRET environment variable not set"
    end

    private def jwt_issuer : String
      ENV["JWT_ISSUER"]? || "#{@project.downcase}-api"
    end

    private def jwt_audience : String
      ENV["JWT_AUDIENCE"]? || "#{@project.downcase}-client"
    end
    <%- end %>

    private def current_user : User?
      <%- if using_jwt? || using_authly? %>
      return @current_user if @current_user

      token = request.headers["Authorization"]?.try(&.sub("Bearer ", ""))
      return nil unless token

      payload = verify_access_token(token)
      return nil unless payload

      user_id = payload["sub"].as_s.to_i64
      @current_user = User.find(user_id)
      <%- else %>
      user_id = session["user_id"]?
      return nil unless user_id
      @current_user ||= User.find(user_id.as(Int64))
      <%- end %>
    rescue
      nil
    end

    <%- if using_jwt? || using_authly? %>
    private def verify_access_token(token : String) : Hash(String, JSON::Any)?
      payload, header = JWT.decode(token, jwt_secret, JWT::Algorithm::HS256)
      validate_token_claims(payload)
      payload
    rescue JWT::Error
      nil
    end
    <%- end %>
  end
end
